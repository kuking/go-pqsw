# PQSW Cryptographic details and technical description

This library will establish a network stream (`net.Conn` contract), the stream of bytes going through the TCP channel 
will be packaged and secured in CGM AEAD Envelops, its' nonces are built using a monotonically increasing packet
sequence number mixed (xor) with a base nonce secretly generated at the session' key-agreement stage, the nonce secret
is not reused as part of AES block ciphers keys.

The underlying block cipher is AES-256 believed to be post-quantum safe (but up to three CGM-AES256 can be wrapped for
future proof; back in the day, DES was supposed to be safe, or 640MB of RAM was considered enough). The session key is
derived using multiple SIDH Sike Kem shared secrets and two portions of a big shared secret chosen by each party.
The shared secret can potentially be big enough (i.e. 10GB) so no two sessions will repeat it in a very long time.
We call this with acknowledged euphemism a _'pragmatic one-time-pad'_ or _'Potp'_.

Finally, each party might have to generate multiples Sike KEMs to satisfy the amount of key-size required, i.e. if a
triple AES-256 is meant to be established, a total of (256+96)*3/8 = 132 bytes of secret will be required, a Fp503 KEM
is of 16 bytes, therefore up to 9 KEMs will be generated by each party, plus 132 bytes of Potp from each party. We are
very conservative regarding a total of four times more secret is generated for the amount required in the final key. 
Each party will generate twice the amount of key-size secret, a full secret-size derived from the KEMs and a full
secret-size from the POTPs, eventually all the secrets are concatenated and xor merged so no single bit of the final key
shall dependent on only one party, one KEM or POTP. We acknowledge this to be excessive, but we took this approach to 
compensate short to medium term risks in the SIDH curves used. 

**CAVEAT EMPTOR**: As in 2020 it is acknowledged some features are not required within the foreseeable future, 
people educated in cryptography would likely agree to be absolutely unnecessary. The author has a background in risk
management and humbly acknowledges future is not perfectly predictable. Therefore, this protocol provides options for
who wants to have the current best encryption, and a few safety mechanisms on top of it. For the sake of prudence.
History books are filled with 'this ought to be good enough' stories. We recommend, given current pqsw verification,
to use standard protocols on top of a pqsw tunnel, i.e. a TLS session on top of a PQSW tunnel until more cryptographic
analysis for PQSW appears.

The protocol validity is not peer reviewed as (May/2020). This implementation is well tested, including edge cases,
noise, and other type of non-cryptographic attacks. The final protocol is simple, lightweight with a reduced surface
of attack in part due to its novelty and explicit simplicity in its design. It does not depends on decades of historic
decisions and backward compatibilities like in TLS, which can make the whole protocol more prone to exploits.

Finally, unless the trade-offs are well understood and managed by the user, we encourage the user continue using TLS 
(https://golang.org/pkg/crypto/tls/).

## Main Features
- Supports multiple keys/curves, so far: Sike Fp503 & Fp751 (thanks to http://github.com/cloudflare/circl).
- Simple implicit key negotiation (facilitating potp & key-rotation)
- Establishes a CGM AEAD AES-256 channel (or three)
- Pragmatic One-Time-Pads (POTP), it can obtain key-secret from a pre-agreed shared random huge secret. This might
  protect against compromised private keys, or more importantly broken curves (considering how relatively new they are).
  - 10Kb of noise encoded as base64 fits in a terminal screen and clipboard
  - a pre-agreed 25GB Blue-ray image can be used to uniquely secure +200M sessions, if AES-256 and the key-exchange
    protocol is trusted, the curves can be turn out to be broken without risk of compromise.
  - In a more practical manner, a 10 Kb. shared secret (fits in a terminal clipboard) can generate 232 unique keys,
    considering the keys can be sliced and cut at any byte offset, there are 10k unique keys (with less entropy).
- Flexibility, POTPs and Public/Private Keys can be issued and shared on client-by-client basis, or per server.
- The final wire session key is compounded with four times the secret required to build it. Each party provides a full
  key with the KEMs and a full key-size with the Potp, this might be redundant but warranties no single bit in the final
  key will be affected by only one party nor KEMs.
    
## Attack preventions
  - Replay attack via persistent bloom filter for KEM secrets and POTPs. (TBI)
  - Private key compromise by using pragmatic One Time Pads (POTPs)
  - Broken curves by using pragmatic One Time Pads (POTPs)
  - Denial of Service, Server CPU Authentication flooding, client is required to calculate a post quantum expensive 
    calculation, also known as Client Puzzle or Proof-of-Work (sha512 leading zeros at the moment.) before the server
    commits resources or discloses information.
  - Ciphertext modification integrity by using CGM
  - PQ-AES Future proof attack: Triple-AES256 using unique full 768 bits of entropy in the key (plus 96*3 of nonce seed)
  - Kem/Sike broken: considering how new the scheme is, it is possible an attack is discovered in the short to medium 
    time. The mitigation to this risk, is to facilitate using the previously described Pragmatic One Time Pads (POTP). 
  - In a world with AES-256 compromised, with a flip in the configuration file, a Triple AES-256 can be enabled.

## Non-core features
- CLI for handling keys, potps, and other configurations, see [pqswcfg documentations](pqswcfg.md)
- CLI to create tunnel servers like in `ssh -Lport:host:hostport`, see [pqswtun documentation](pqswtun.md).
- Adaptive puzzle difficulty challenge based on ip/failure ratio.

## Protocol flow
[Complete Protocol Specification here.](protocol.md)
